I WSTĘP - INSTALACJA NARZĘDZI I PROGRAMÓW 
-----------------------------------------
AKTUALNA: Zestaw .NET Core SDK (3.0.1)
https://github.com/mariuszjurczenko




1)
- instalujemy starszą wersję (2.2).NET 
bo tak jes używana w przykaładach.
Na wersji (3.0) przykłady będą miały błedy. 

1a)
dodntet --version
Zestaw .NET Core SDK (2.2)


2)
nodejs  --vesrison
3)
download vscode 
instalujemy extendsion:
-> C# for Visual Studio Code (powered by OmniSharp).
-> C# IDE Extensions for VSCode
-> nuget-package-manager
-> Angular 8 Snippets
-> Angular Files
-> Angular Language Service
-> angular2-switcher
-> Auto Rename Tag
-> Bracket Pair Colorizer
-> Debugger for Chrome
-> Material Icon Theme
-> Path Intellisense
-> Prettier Formatter for Visual Studio Code
-> TSLint support for Visual Studio Code

4)
download postman
download sql lite


II
------------------------------------------
II TWORZENIE PROJEKTU PORTALU RANDKOWEGO
- będziemy tworzyć nowy projekt .net core web api za pomocą cli.

1)
C:\dev\dotnet\PortalRandkowy>dotnet new webapi -o PortalRandkowy.API -n PortalRandkowy.API
The template "ASP.NET Core Web API" was created successfully.
Processing post-creation actions...
Running 'dotnet restore' on PortalRandkowy.API\PortalRandkowy.API.csproj...
  Ukończono przywracanie w elemencie 61,65 ms (C:\dev\dotnet\PortalRandkowy\PortalRandkowy.API\PortalRandkowy.API.csproj).
Restore succeeded.
C:\dev\dotnet\PortalRandkowy>

2)
- odpalamy w vs-code
c:\dev\dotnet\PortalRandkowy>code .


3)
C:\dev\dotnet\PortalRandkowy\PortalRandkowy.API>dotnet run
.NET(3.0)
BROWSER
https://localhost:5001/WeatherForecast

[{"date":"2019-11-12T21:08:30.2919024+01:00","temperatureC":32,"temperatureF":89,"summary":"Scorching"},{"date":"2019-11-13T21:08:30.2919315+01:00","temperatureC":-4,"temperatureF":25,"summary":"Bracing"},{"date":"2019-11-14T21:08:30.2919322+01:00","temperatureC":-20,"temperatureF":-3,"summary":"Balmy"},{"date":"2019-11-15T21:08:30.2919326+01:00","temperatureC":31,"temperatureF":87,"summary":"Cool"},{"date":"2019-11-16T21:08:30.2919329+01:00","temperatureC":18,"temperatureF":64,"summary":"Hot"}]




3a)
.NET(2.2)
http://localhost:5000/api/Values



4)
- rezygnujemh z https.
lounch.settings
"applicationUrl": "https://localhost:5001;http://localhost:5000",
"applicationUrl": "http://localhost:5000",



5)
http://localhost:5000/WeatherForecast
[{"date":"2019-11-12T21:13:57.7511092+01:00","temperatureC":50,"temperatureF":121,"summary":"Warm"},{"date":"2019-11-13T21:13:57.7552457+01:00","temperatureC":23,"temperatureF":73,"summary":"Sweltering"},{"date":"2019-11-14T21:13:57.7552527+01:00","temperatureC":30,"temperatureF":85,"summary":"Chilly"},{"date":"2019-11-15T21:13:57.7552533+01:00","temperatureC":20,"temperatureF":67,"summary":"Cool"},{"date":"2019-11-16T21:13:57.7552536+01:00","temperatureC":26,"temperatureF":78,"summary":"Hot"}]

6)
Generujemy wyjątek poto by obejżeć stronę wyjątku w trybie dev.

    "PortalRandkowy.API": {
      "commandName": "Project",
      "launchBrowser": true,
      "launchUrl": "weatherforecast",
      "applicationUrl": "http://localhost:5000",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }


        [HttpGet]
        public IEnumerable<WeatherForecast> Get()
        {
             throw new Exception("Generujemy wyjątek");
            var rng = new Random();
            return Enumerable.Range(1, 5).Select(index => new WeatherForecast
            {
                Date = DateTime.Now.AddDays(index),
                TemperatureC = rng.Next(-20, 55),
                Summary = Summaries[rng.Next(Summaries.Length)]
            })
            .ToArray();
        }


7)
W trybie produkcyjnym nie zobaczymy szczegółów opisu błędu a tym bardziej kodu.
http://localhost:5000/WeatherForecast
BROWSER:
Ta strona nie działaSerwer localhost nie może teraz obsłużyć tego żądania.
HTTP ERROR 500


8)
C:\dev\dotnet\PortalRandkowy\PortalRandkowy.API>dotnet watch run
- modyfikujemy kod w trakcie utuchomienia servra i on reaguje na zmiany, raz wyświetla a raz nie wyświetla wyjątku tylko poprawne wartości
zależy to od tego czy zakomentujemy czy nie zakomentujemy wyjątku.
throw new Exception("Generujemy wyjątek");



9)
C:\dev\dotnet\PortalRandkowy
.git -inicjalizujemy gita
.gitgnore - dodajemy i uzupełniamy aby nie dodawać do repozytorim zbędnych plików.

10)
zawartość pliku .gitgnore
.vscode
bin
obj
*.db
wwwroot

11)
- gita możemy obsłużyć w konsli lub korzystając z vscode.
teraz możemy przejść do repozytoeium gita mamay 10 plików do dodania a nie 100.
git add.
git commit -m "Utworzenie Projektu Portal Randkowy Web Api"


12)
- oddaliśmy pliki do naszego repozytorium lokalnego i mamy wersjonowanie kodu.


13)
- tworzymy na githubie nowe repozytorieum o nazwie PortalRandkowy
- wysyłamy pliki do zdalnego repozytorium.
C:\dev\dotnet\PortalRandkowy>git remote add origin https://github.com/andrzej-sedzik-dev/PortalRandkowy.git
git push -u origin master

C:\dev\dotnet\PortalRandkowy>git push -u origin master
remote: Resolving deltas: 100% (1/1), done.


14)
Tworzymy model Value.

  namespace PortalRandkowy.API.Models
  {
      public class Value
      {
          public int Id { get; set; }
          public string Name  { get; set; }

      }
  }

15)
Połączenie z bazą danych.

namespace PortalRandkowy.API.Data
{
    public class DataContext : DbContext
    {
        public DataContext(DbContextOptions<DataContext> options) : base(options){}

        public DbSet<Value> Values { get; set; }
    }
}


16)
Teraz musimy przejść do naszej klasy Startup.cs i zarejestrować nasz DbContext.
- dodajemy więc do kolekcji servisów DbContext.


       public void ConfigureServices(IServiceCollection services)
        {
            services.AddDbContext<DataContext>(x => x.UseSqlite("Connectionstring"))    
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
        }


17)
UseSqlite, jest nierozpoznawalny, dlatego musimy poprzez nuget dodać odpowiednie zalrzności.
CTR+SHIF+P -> nuget packet manager: add package
- chcemy dodać pakiet do Sqlite:
Microsoft.EntityFrameworkCore.Sqlite
versin 2.2.4
Success!

18)
- jeśli są problemy z pobieraniem paiketów.
RESTORE ALL PROJECT.


19)
- budujemy projekt aby sprawdzić czy nie ma błędów.
dotnet build

  Ukończono przywracanie w elemencie 765,58 ms (C:\dev\dotnet\PortalRandkowy\PortalRandkowy.API\PortalRandkowy.API.csproj).
  PortalRandkowy.API -> C:\dev\dotnet\PortalRandkowy\PortalRandkowy.API\bin\Debug\netcoreapp2.2\PortalRandkowy.API.dll

Kompilacja powiodła się.
    Ostrzeżenia: 0
    Liczba błędów: 0


20)
Przygotowujemy źródło bazy danych.
application.json

"ConnectionStrings":{
    "DefaultConnection": "Data Source = PortalRandkowy.db"
  },

21)
Konfigurjmey połąćzenie
Startup.cs

public void ConfigureServices(IServiceCollection services)
        {
            services.AddDbContext<DataContext>(x => x.UseSqlite(Configuration.GetConnectionString("DefaultConnection")));   
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
        }

22)
TWORZYMY BAZĘ DANYCH W TERMINALU.

C:\dev\dotnet\PortalRandkowy>dodnet ef
'dodnet' is not recognized as an internal or external command,
operable program or batch file.

C:\dev\dotnet\PortalRandkowy>dotnet ef

                     _/\__       
               ---==/    \\      
         ___  ___   |.    \|\
        | __|| __|  |  )   \\\
        | _| | _|   \_/ |  //|\\
        |___||_|       /   \\\/\\

Commands:
  database    Commands to manage the database.
  dbcontext   Commands to manage DbContext types.
  migrations  Commands to manage migrations.


23)

C:\dev\dotnet\PortalRandkowy>dotnet ef migrations add InitialCreateDb
No project was found. Change the current working directory or use the --project option.


24)
C:\dev\dotnet\PortalRandkowy\PortalRandkowy.API>dotnet ef migrations add InitialCreateDb
info: Microsoft.EntityFrameworkCore.Infrastructure[10403]
      Entity Framework Core 2.2.6-servicing-10079 initialized 'DataContext' using provider 'Microsoft.EntityFrameworkCore.Sqlite' with options: None
Done. To undo this action, use 'ef migrations remove'


25)
Mamy już migrację teraz na podstawie tej migracji utworzymy sobie baze danych.
C:\dev\dotnet\PortalRandkowy\PortalRandkowy.API>dotnet ef database update
- baza danych zostanie utworzona i zotaną wykorzystane wszystkie migracje obecnie mamay jedną

26)
W naszym projekcie powstł plik PortalRandkowy.db
- aby przeglądać zawartość bazy danych instalujemy dbbrowser i teraz go urzyjemy
https://sqlitebrowser.org/blog/version-3-11-2-released/


27)
Dodajemy wartośći do tabli Values.

1	wartosc 1
2	wartosc 2
3	wartosc 3
4	wartosc 4
5	wartosc 5

- zamykamy bazę danych.

28)
ValuesController.cs
- dodajmy konstruktor i zmienną

        private readonly DataContext _context;

        public ValuesController(DataContext context)
        {
            _context = context;
        }


29)
BEFORE:

       // GET api/values
        [HttpGet]
        public ActionResult<IEnumerable<string>> Get()
        {
            return new string[] { "value1", "value2" };
        }



30)
AFTER:

        [HttpGet]
        public IActionResult GetValues()
        {

            var values = _context.Values.ToList();
            return Ok(values);
        }



31)
BEFORE:

        // GET api/values/5
        [HttpGet("{id}")]
        public ActionResult<string> Get(int id)
        {
            return "value";
        }


32)
AFTER:


        // GET api/values/5
        [HttpGet("{id}")]
        public IActionResult GetValue(int id)
        {
            var value = _context.Values.FirstOrDefault(x => x.Id == id);
            return Ok(value);
        }

33)
BEFORE:
        // POST api/values
        [HttpPost]
        public void Post([FromBody] string value)
        {
        }
AFTER:

  // POST api/values
        [HttpPost]
        public void AddValue([FromBody] Value value)
        {
              _context.Values.Add(value);
              _context.SaveChanges();  
        }


34)
BEFORE:
        // PUT api/values/5
        [HttpPut("{id}")]
        public void Put(int id, [FromBody] string value)
        {
        }


35)
AFTER:

        // PUT api/values/5
        [HttpPut("{id}")]
        public void EditValue(int id, [FromBody] Value value)
        {
            var data = _context.Values.Find(id);
            data.Name = value.Name;
            _context.Values.Update(data);
            _context.SaveChanges();
        }

36)

        // DELETE api/values/5
        [HttpDelete("{id}")]
        public void DeleteValue(int id)
        {
            var data = _context.Values.Find(id);
            _context.Values.Remove(data);
            _context.SaveChanges();
        }




37)
W przypadku dodawania wartośći również moglibyśmy dodać status ActionResult.

        // POST api/values
        [HttpPost]
        public IActionResult AddValue([FromBody] Value value)
        {
              _context.Values.Add(value);
              _context.SaveChanges(); 
              return Ok(value); 
        }


38)
To samo w przypadku edycji.

        // PUT api/values/5
        [HttpPut("{id}")]
        public IActionResult EditValue(int id, [FromBody] Value value)
        {
            var data = _context.Values.Find(id);
            data.Name = value.Name;
            _context.Values.Update(data);
            _context.SaveChanges();
            return Ok(data); 
        }



39)
Przy usówaniu również:

        // DELETE api/values/5
        [HttpDelete("{id}")]
        public IActionResult DeleteValue(int id)
        {
            var data = _context.Values.Find(id);
            _context.Values.Remove(data);
            _context.SaveChanges();
            return Ok(data); 
        }

40)
Mamy już oprogramowane metody, możemy je wypróbować na postmanie.
Teraz będziemy mogli wyslać zapytania do aplikacji, bez konieczności posiadania klienta.

41)
[GET]
POSTMAN:
http://localhost:5000/api/values


[
    {
        "id": 1,
        "name": "wartosc 1"
    },
    {
        "id": 2,
        "name": "wartosc 2"
    },
    {
        "id": 3,
        "name": "wartosc 3"
    },
    {
        "id": 4,
        "name": "wartosc 4"
    },
    {
        "id": 5,
        "name": "wartosc 5"
    }
]


42)
[GET]
POSTMAN:
http://localhost:5000/api/values/5


    {
        "id": 5,
        "name": "wartosc 5"
    }


43)
[POST]
POSTMAN:
http://localhost:5000/api/values
/body/row/json.


{
	"Name": "wartość testowa"
}

SEND
200OK
{
    "id": 6,
    "name": "wartość testowa"
}



44)
[GET]
POSTMAN:
http://localhost:5000/api/values


[
    {
        "id": 1,
        "name": "wartosc 1"
    },
    {
        "id": 2,
        "name": "wartosc 2"
    },
    {
        "id": 3,
        "name": "wartosc 3"
    },
    {
        "id": 4,
        "name": "wartosc 4"
    },
    {
        "id": 5,
        "name": "wartosc 5"
    }
       {
        "id": 6,
        "name": "wartosc testowa"
    }
       {
        "id": 7,
        "name": "wartosc testowa"
    }
]



45)
[PUT]
http://localhost:5000/api/values/7
/body/row/json.
{
    "id": 7,
    "name": "wartość testowa edycja"
}


46)
[DELETE]
localhost:5000/api/values/6

[
    {
        "id": 1,
        "name": "wartosc 1"
    },
    {
        "id": 2,
        "name": "wartosc 2"
    },
    {
        "id": 3,
        "name": "wartosc 3"
    },
    {
        "id": 4,
        "name": "wartosc 4"
    },
    {
        "id": 5,
        "name": "wartosc 5"
    },
    {
        "id": 7,
        "name": "wartość testowa edycja"
    }
]


47)
Jeśłi sprubójemy usówać wartość której nie ma
500Internal Server Error
174ms
21.85 KB
An unhandled exception occurred while processing the request.
ArgumentNullException: Value cannot be null.
Parameter name: entity


48)
BEFORE:
        public IActionResult DeleteValue(int id)
        {
            var data = _context.Values.Find(id);
            _context.Values.Remove(data);
            _context.SaveChanges();
            return Ok(data); 
        }

AFTER:

        // DELETE api/values/5
        [HttpDelete("{id}")]
        public IActionResult DeleteValue(int id)
        {
            var data = _context.Values.Find(id);

            if(data == null)
            return NoContent();


            _context.Values.Remove(data);
            _context.SaveChanges();
            return Ok(data); 
        }




49)
[DELETE]
localhost:5000/api/values/6


STATUS: 204 No Content





















